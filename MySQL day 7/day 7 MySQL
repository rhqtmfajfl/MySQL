day 7






몽고 디비 mongoexport json 형식의 파일을 데리고 나오는 것 

~~.json이 좋다.

export 할 때 몽고 디비 명령어

mongoexport --db 데이터베이스명 -c 컬렉션명 --out 파일 경로 + 파일 명(없으면 새로 만들어서 넣는다.)  test.json

mongoimport --db 데이터베이스명 -c 컬렉션명 --out 파일 경로 




//////////////


20 페이지 

> db.book.find({},{‘name’ : true})
 첫번째 공백 으로 주고 name을 ture를하면 이름을 출력하겠다.
 
 
 db.book.find({},{'name' : true, '_id' : false})
 
 이름은 true로 출력하고 id는 false로 안보이게 한다.
 
 name : 1은 treu id : 0 하면 false로 출력 안한다.
 
 여기서 1이외에 다른 정수가 와도 된다.
 
 
 
 **
  db.book.find({},{name : true, price : 1, _id : false})  -> 가능
 _id를 false로 주면 나머지 필드들의 value를 true나 false 둘중 한개의 값으로 다 통일 해야 한다.
아니면 _id가 등장하지 않으면 다른 필드들의 값이 달라도 괜찮다.
 db.book.find({},{name : true, price : 0}) 일때 다르게 가능
 
 
  db.book.find({},{name : true, price : 0, _id : false})
  db.book.find({},{name : false, price : 1, _id : false})
   이런 것들은 불가능하다.
**





find()에서{} 첫번째는 필터링 정보
필터링 정보를 생략하면 필드 정보의 내용이 필터링정보로 생각된다.

find()에서 객체의형식은 갖춰야하기 때문에 {} 중괄호 형태가 정확히 와야 된다.

예외로 db.book.find(null, {'name':1}) 가능 
조건이 없는 경우라면 null 을 주거나 {} 객체를 주면 된다.

단!!!! 생략 하면 안된다.




###
db.book.find(
{price : {$lt : 10000}}  , {name : true, price : true, _id : false})
이 문장은 필터링의 정보와 객체의 정보를 두다 줬다.

이 몽고디비 구문은 전달하고하는 데이터를 json 객체로 전달하고자 한다.

json 객체는  중괄호 주고 안에 네입 벨류로 중괄호를 더 하나 더준덗

연산자를 json 객체에서 name 으로 사용하고 있다.

{price : {$lt : 10000}}  ->>>>>> 필터에 해당하는 객체 
객체를 필터 하고자 하는 조건
이 문장은 select 에서 where 절이 하는 일이다.



그리고
{name : true, price : true, _id : false}  value도 객체이다.
추출하고자하는 컬럼의 정보

필드 정보를 담고자하는 객체에 id 가 오면 다른 필드는똑같이 와야 한다.

이 부분은 sql문에서 select 절이 하는 일이다.


###
db.book.find({$and : [ {price : {$gte : 10000}}, {price : {$lt : 20000}}]}, {name : true, price : true, _id : false}

여기서 

{$and : [ {price : {$gte : 10000}}, {price : {$lt : 20000}}]}  -> json 형식으로 연산자를 만들었다.
객체에 값을 여러개 주고 싶으면 [] 배열 사용

and 논리 곱이라는 의미 두개의 비교식이 모두 같을때 true

두개의 벨류  식을 줘야 하니까 리스트로 하고 있다.

첫번재 비교식도 중과호 두번째 비교식도 중괄호

pirce 가 10000보다 크거나 같고

20000원 보다는 작은 데이터의 정보만 출력 하겠다.




메소드 호출 할 때 argument로 호출 해야 한다.






어떤 조건에 만족하는 것을 꺼낸다음에 도큐먼트의 개수만 알 고 싶을 때

(자바에서 메소드 호출할때 매개변수 사항에 맞춰서 argument 를 반드시 반환 해야 한다.)


void print(int p1, String p2) 매개 변수를정의 했다 하면

print(10, "abc") 매개변수의 개수를 맞춰야 하지만

자바스크립트는 매개변수가 3개 있어도 argument를 3개가 아니라 4개 전달 해도 오류가 안생긴다.

두개의 매개 변수가 있는데
하나의 argument를 전달해도 에러가 안난다.

그런데 순서적으로 p1한테는 전달 안하고 p2한테만 전달하는게 안된다.

그래서 필터에 null이라도 줘야한다.


가격이 8000원 초과인

find 메소드는 리턴값의 유형이 디비 쿼리 객체의 count라는 메소드를 호출하여 추출된 도큐먼트 개수를 알 수 있다.





> db.book.find({"name": { "$regex" : "^java"}})

여기서 $는 연산자를 정의 할 때 사용

name이 자바로 시작하는 데이터만 꺼내라


$regex 연산자는 생략 가능하다.

 db.book.find({"name": /^java/})


앞에 / 슬래시를 붙이면 정규 표현식 객체로 인식 한다. 정규 표현식 객체를 연산자로 사용 가능

$regex는 기능이 한두가지 더 있는데 그닥 안쓴다. 그래서 $regex 대신 /가 더 간편하다. 앞뒤에 / 를 붙이면 정규식표현이 되는 것은 자바 스크립트의 기능이다.





 배열 데이터에 대한 쿼리 ]
db.inventory.insertMany([
 { item: "journal", qty: 25, tags: ["blank", "red"], dim_cm: [ 14, 21 ] },
 { item: "notebook", qty: 50, tags: ["red", "blank"], dim_cm: [ 14, 21 ] },
 { item: "paper", qty: 100, tags: ["red", "blank", "plain"], dim_cm: [ 14, 21 ] },
 { item: "planner", qty: 75, tags: ["blank", "red"], dim_cm: [ 22.85, 30 ] },
 { item: "postcard", qty: 45, tags: ["blue"], 
 dim_cm: [ 10, 15.25 ] }
]);

db.inventory.find( { tags: ["red", "blank"] } )  태그s 의 값이 red blank인것만 찾아라

red blank인 도큐먼트가 두번째 도큐먼트이다.

db.inventory.find( { tags: 
 { $all: ["red", "blank"] } } )
 
 $all 이라는 연산자를 사용하면 red blank
 blank red인것 그리고 그외에 red blank plain 인 것을 다 찾는다.
 
 순서 상관 없이 red나 blank를 가지고만 있으면 값들을 추출한다. red가 ㄷ

db.inventory.find( { dim_cm: { $gt: 25 } } )
dim_cm은 25이상인 것을 찾아라는 의미 이다.


배열안에서 큰값을 가지고 있는것





db.inventory.find( { dim_cm: { $elemMatch: { $gt: 22, $lt: 30 } } } 이 두사이의 값들이 들어있는 모든 것을 다 출력 

$eleMatch는  22보다 크고 30보다 작은 값이 하나라도 있으면,

각각의 값이랑 맞는것 출력



db.inventory.find( { "dim_cm.1": { $gt: 25 } } )
dim_cm의 첫번째를 꺼내 겠다.


db.inventory.find( { "tags": { $size: 3 } } 

tags의 크기가 3인것을 출력하겠다.



db.inventory.find( { "dim_cm.1": { $gt: 25 } } )

dim_cm.1은 "" 를 사용해서 안에 넣어줘야 한다.



db.inventory.find( { "tags": { $size: 3 } } )

이값은 tags안의 배열의 크기 사이즈 안의 요소의 개수가 3개인 것들을 출력한다.

$size : 2하면 ["red","blank"] 같은 것들 출력



db.inventory.find( { "dim_cm.0": { $eq: 14 } } )  0 은 필드 의 0번째 이다. 0번째의 원소가 14인 것을 꺼내겠다.
. 은 값에 해당하는 객체에 접근 할 때

필드에 . 을 사용할 때는 인용 부호 "" '' 를 사용해서 묶어줘야하낟.




vlaue 값이 임베디드 객체인 경우



[ 임베디드 객체에 대한 쿼리 ]

db.inventory1.insertMany( [
 { item: "journal", qty: 25, size: { h: 14, w: 21,  임베디드 객체 형식으로 size 필드의 값을 구성하고 있다.
 uom: "cm" }, status: "A" },
 { item: "notebook", qty: 50, size: { h: 8.5, w: 11, 
 uom: "in" }, status: "A" },
 { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
 { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
 { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" }
]);

json 안에 또 json 형식이 들어오는 것을 임베디드 방식이라고 한다.

db.inventory1.find()



db.inventory1.find( { size: { h: 14, w: 21, uom: "cm" } } , {_id : false})

id를 제외한 나머지는 다 출력

id 를 true로 하면 나머지는 안나오고 id 만 나온다.





db.inventory1.find( { "size.uom": "in" }, {_id : false} )
만약 size에서 uom이 in이 것을 찾아라 할 때 사용

size.h : 14 하면 h가 14인 것을 찾겠다.



db.inventory1.find( { "size.h": { $lt: 15 } }, {_id : false} )
size.h:$lt: 15 하면 size.h가 15보다 작은 것을 찾겠다.

size.h가 h가 15보다 작은 것을 찾겠다.

db.inventory1.find( { "size.h": { $lt: 15 }, "size.uom": "in", status: "D" }, {_id : false} 
size.h가 15보다 작고 uom이 D인것을 찾겠다.

만약 uom 밑에(valud) 도 객체가 있으면 . 으로 계속 연결해 가면 된다.




[ 임베디드 객체를 원소로 갖는 배열 대한 쿼리 ]

db.inventory2.insertMany( [
 { item: "journal", instock: [ { warehouse: "A", qty: 5 }, { warehouse: "C", qty: 15 } ] },
 { item: "notebook", instock: [ { warehouse: "C", qty: 5 } ] },
 { item: "paper", instock: [ { warehouse: "A", qty: 60 }, { warehouse: "B", qty: 15 } ] },
 ###{ item: "planner", instock: [ { warehouse: "A", qty: 40 }, { warehouse: "B", qty: 5 } ] },  나는 이걸 입력안했음
 { item: "postcard", instock: [ { warehouse: "B", qty: 15 }, { warehouse: "C", qty: 35 } ] }
 
 원소들이 객체인 배열을 객체 배열이라고 한다.
 
 


db.inventory2.find( { 'instock.0.qty': { $lte: 20 } } )

instock이라는 배열에 할당된 배열에 0번째에 qty가 30보다 작거나 같으면



db.inventory2.find( { "instock": { warehouse: "A", qty: 5 } } ) -> instcok에서 warehouse가 "A"이고 qty가 5인 것을 출력한다.
결과 : { item: "journal", instock: [ { warehouse: "A", qty: 5 }, { warehouse: "C", qty: 15 } ] },


db.inventory2.find( { "instock": { qty: 5, warehouse: "A" } } ) - > instock에서 qty가 5 이고 warehouse가 "A"인것이 나온다.
결과 아무것도 출력되지 않는다. 이유는 QTY와 WAREHOUSE의 순서가 다르기 때문에

db.inventory2.find( { 'instock.qty': { $lte: 20 } } )
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d5f"), "item" : "journal", "instock" : [ { "warehouse" : "A", "qty" : 5 }, { "warehouse" : "C", "qty" : 15 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d60"), "item" : "notebook", "instock" : [ { "warehouse" : "C", "qty" : 5 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d61"), "item" : "paper", "instock" : [ { "warehouse" : "A", "qty" : 60 }, { "warehouse" : "B", "qty" : 15 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d62"), "item" : "postcard", "instock" : [ { "warehouse" : "B", "qty" : 15 }, { "warehouse" : "C", "qty" : 35 } ] }


instock.qty에서 lte가 20보다 작은 것을 가지고 있는 instock의 모든 qty가 다 출력 된다. instock 배열에 qty를 가지고 있는 객체는데 20보다 작은게 하나라도 있으면 그 배열 다 출력

db.inventory2.find( { 'instock.0.qty': { $lte: 20 } } )
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d5f"), "item" : "journal", "instock" : [ { "warehouse" : "A", "qty" : 5 }, { "warehouse" : "C", "qty" : 15 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d60"), "item" : "notebook", "instock" : [ { "warehouse" : "C", "qty" : 5 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d62"), "item" : "postcard", "instock" : [ { "warehouse" : "B", "qty" : 15 }, { "warehouse" : "C", "qty" : 35 } ] }

여기서는 instock.0.qty이므로 instco의 배열에서 0번째 객체에서 qty가 20보다 작은 것 들만 출력하므로 위의 instco.qty보다 하나 작게 출력 된다.

 db.inventory2.find( { "instock": { $elemMatch: { qty: 5, warehouse: "A" } } } )
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d5f"), "item" : "journal", "instock" : [ { "warehouse" : "A", "qty" : 5 }, { "warehouse" : "C", "qty" : 15 } ] }

여기서는 instock의 warehouse에서 "A"인것과 qty가 5인 것을 가지고 있으면 출력된다.




> db.inventory2.find( { "instock": { $elemMatch: { qty: { $gt: 10, $lte: 20 } } } } )
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d5f"), "item" : "journal", "instock" : [ { "warehouse" : "A", "qty" : 5 }, { "warehouse" : "C", "qty" : 15 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d61"), "item" : "paper", "instock" : [ { "warehouse" : "A", "qty" : 60 }, { "warehouse" : "B", "qty" : 15 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d62"), "item" : "postcard", "instock" : [ { "warehouse" : "B", "qty" : 15 }, { "warehouse" : "C", "qty" : 35 } ] }


여기서는 intock에서 qty가 10보다 크고 20보다 작은것들을 출력이므로 
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d60"), "item" : "notebook", "instock" : [ { "warehouse" : "C", "qty" : 5 } ] }
이거는 출력이 되지 않는다.





 db.inventory2.find( { "instock.qty": { $gt: 10, $lte: 20 } } )
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d5f"), "item" : "journal", "instock" : [ { "warehouse" : "A", "qty" : 5 }, { "warehouse" : "C", "qty" : 15 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d61"), "item" : "paper", "instock" : [ { "warehouse" : "A", "qty" : 60 }, { "warehouse" : "B", "qty" : 15 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d62"), "item" : "postcard", "instock" : [ { "warehouse" : "B", "qty" : 15 }, { "warehouse" : "C", "qty" : 35 } ] }




db.inventory2.find( { "instock.qty": 5, "instock.warehouse": "A" } )

> db.inventory2.find( { "instock.qty": 5, "instock.warehouse": "A" } )
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d5f"), "item" : "journal", "instock" : [ { "warehouse" : "A", "qty" : 5 }, { "warehouse" : "C", "qty" : 15 } ] }



객체 단위로 체크해서 만족하는게 있으면 그 행을 꺼낸다.

db.inventory2.find("instock":{$elemMatch:{qty:{$gt:10,$


이거를 만ㄷ족하는 애가 하나라도 있나 qty가 만족하는게 하나라도 있으면 
gt 에 만족하는애가 있으면, 

lte20을 만족하는 애가 있으며

각각의 조건을 만족하는게 잇으면 꺼낸다.





/////////////////////////////////////////
23페이지



몽고디비에서 저장단위 도큠ㄴ트


값이 객체인 경우 임베딩 객체라고 한다.






[ 반환(return) 값 : Cursor 객체 ]
query에 해당하는 Document들을 선택하여 cursor를 반환한다. cursor 는 query 요청의 결과값을 가르키는 pointer 이다. 
Cursor 객체를 통해서 보이는 데이터의 수를 제한할 수 있고, 데이터를 sort 할 수도 있다. 생성된 Cursor 객체의 내용은 한 번만
읽을 수 있으며 10분동안 사용하지 않으면 만료된다.



find한 결과를 변수에 담는다.


자바스크립트는 자바와 다르게

자바는 타입을 설정하지만(그래서 타입의 값만 저장 할 수 있다)  변수가 받게될 값을 고정 시킴으로서 얻을수 있는 장점도 있고 단ㄷ점도 잇다.


자바스크립트는 타입의 값
고정하는것도 아니고 고정 안하는것도 아니다 어떤값을 사용할거라는 값만 저장한다.

이때 사용하는 예약어가 var가 있다.

rat이나 con어쩌고 가 있다.

var를 안붙이면 변수명을 mycursor라고 하는 이유는

jdbc의 result도 커서 객체이다.

jdbc의 result 셋의 장점은 포워드 방향으로 한번만 읽을 수 있다.

cursor 객체의 공통된 내요은 한번만 읽을 수 있으며 

10분동안 사용ㅈ만료된다.


\



도큐먼트를 변수에 담는 이유는 

하나하나 한 도큐먼트씩 꺼내기 위해서이다.

hasNext()와

next() 메소드를 사용하여 하나 하나 꺼내온다.

resultSet은 다음해으로 next가 찾는동안  넘어갔다 안ㄴ넘어갔다 알수 있다.??????????


다음 도큐먼트로 넘어가는 기능만 한다.

hasNext가 참인동안 하나하나 꺼내와라

자바는 어떤 객체를 출력하시오라고 하면 자동으로 toString이 출력된다.
이것도 마찬가지로 toString으로 출력되어서 object bson이라고 나온다.






printjson(doc)

json 형식으로 doc 먼트를 내용을 json형식으로 내보내 준다.




   
