day 7






몽고 디비 mongoexport json 형식의 파일을 데리고 나오는 것 

~~.json이 좋다.

export 할 때 몽고 디비 명령어

mongoexport --db 데이터베이스명 -c 컬렉션명 --out 파일 경로 + 파일 명(없으면 새로 만들어서 넣는다.)  test.json

mongoimport --db 데이터베이스명 -c 컬렉션명 --out 파일 경로 




//////////////


20 페이지 

> db.book.find({},{‘name’ : true})
 첫번째 공백 으로 주고 name을 ture를하면 이름을 출력하겠다.
 
 
 db.book.find({},{'name' : true, '_id' : false})
 
 이름은 true로 출력하고 id는 false로 안보이게 한다.
 
 name : 1은 treu id : 0 하면 false로 출력 안한다.
 
 여기서 1이외에 다른 정수가 와도 된다.
 
 
 
 **
  db.book.find({},{name : true, price : 1, _id : false})  -> 가능
 _id를 false로 주면 나머지 필드들의 value를 true나 false 둘중 한개의 값으로 다 통일 해야 한다.
아니면 _id가 등장하지 않으면 다른 필드들의 값이 달라도 괜찮다.
 db.book.find({},{name : true, price : 0}) 일때 다르게 가능
 
 
  db.book.find({},{name : true, price : 0, _id : false})
  db.book.find({},{name : false, price : 1, _id : false})
   이런 것들은 불가능하다.
**





find()에서{} 첫번째는 필터링 정보
필터링 정보를 생략하면 필드 정보의 내용이 필터링정보로 생각된다.

find()에서 객체의형식은 갖춰야하기 때문에 {} 중괄호 형태가 정확히 와야 된다.

예외로 db.book.find(null, {'name':1}) 가능 
조건이 없는 경우라면 null 을 주거나 {} 객체를 주면 된다.

단!!!! 생략 하면 안된다.




###
db.book.find(
{price : {$lt : 10000}}  , {name : true, price : true, _id : false})
이 문장은 필터링의 정보와 객체의 정보를 두다 줬다.

이 몽고디비 구문은 전달하고하는 데이터를 json 객체로 전달하고자 한다.

json 객체는  중괄호 주고 안에 네입 벨류로 중괄호를 더 하나 더준덗

연산자를 json 객체에서 name 으로 사용하고 있다.

{price : {$lt : 10000}}  ->>>>>> 필터에 해당하는 객체 
객체를 필터 하고자 하는 조건
이 문장은 select 에서 where 절이 하는 일이다.



그리고
{name : true, price : true, _id : false}  value도 객체이다.
추출하고자하는 컬럼의 정보

필드 정보를 담고자하는 객체에 id 가 오면 다른 필드는똑같이 와야 한다.

이 부분은 sql문에서 select 절이 하는 일이다.


###
db.book.find({$and : [ {price : {$gte : 10000}}, {price : {$lt : 20000}}]}, {name : true, price : true, _id : false}

여기서 

{$and : [ {price : {$gte : 10000}}, {price : {$lt : 20000}}]}  -> json 형식으로 연산자를 만들었다.
객체에 값을 여러개 주고 싶으면 [] 배열 사용

and 논리 곱이라는 의미 두개의 비교식이 모두 같을때 true

두개의 벨류  식을 줘야 하니까 리스트로 하고 있다.

첫번재 비교식도 중과호 두번째 비교식도 중괄호

pirce 가 10000보다 크거나 같고

20000원 보다는 작은 데이터의 정보만 출력 하겠다.




메소드 호출 할 때 argument로 호출 해야 한다.






어떤 조건에 만족하는 것을 꺼낸다음에 도큐먼트의 개수만 알 고 싶을 때

(자바에서 메소드 호출할때 매개변수 사항에 맞춰서 argument 를 반드시 반환 해야 한다.)


void print(int p1, String p2) 매개 변수를정의 했다 하면

print(10, "abc") 매개변수의 개수를 맞춰야 하지만

자바스크립트는 매개변수가 3개 있어도 argument를 3개가 아니라 4개 전달 해도 오류가 안생긴다.

두개의 매개 변수가 있는데
하나의 argument를 전달해도 에러가 안난다.

그런데 순서적으로 p1한테는 전달 안하고 p2한테만 전달하는게 안된다.

그래서 필터에 null이라도 줘야한다.


가격이 8000원 초과인

find 메소드는 리턴값의 유형이 디비 쿼리 객체의 count라는 메소드를 호출하여 추출된 도큐먼트 개수를 알 수 있다.





> db.book.find({"name": { "$regex" : "^java"}})

여기서 $는 연산자를 정의 할 때 사용

name이 자바로 시작하는 데이터만 꺼내라


$regex 연산자는 생략 가능하다.

 db.book.find({"name": /^java/})


앞에 / 슬래시를 붙이면 정규 표현식 객체로 인식 한다. 정규 표현식 객체를 연산자로 사용 가능

$regex는 기능이 한두가지 더 있는데 그닥 안쓴다. 그래서 $regex 대신 /가 더 간편하다. 앞뒤에 / 를 붙이면 정규식표현이 되는 것은 자바 스크립트의 기능이다.





 배열 데이터에 대한 쿼리 ]
db.inventory.insertMany([
 { item: "journal", qty: 25, tags: ["blank", "red"], dim_cm: [ 14, 21 ] },
 { item: "notebook", qty: 50, tags: ["red", "blank"], dim_cm: [ 14, 21 ] },
 { item: "paper", qty: 100, tags: ["red", "blank", "plain"], dim_cm: [ 14, 21 ] },
 { item: "planner", qty: 75, tags: ["blank", "red"], dim_cm: [ 22.85, 30 ] },
 { item: "postcard", qty: 45, tags: ["blue"], 
 dim_cm: [ 10, 15.25 ] }
]);

db.inventory.find( { tags: ["red", "blank"] } )  태그s 의 값이 red blank인것만 찾아라

red blank인 도큐먼트가 두번째 도큐먼트이다.

db.inventory.find( { tags: 
 { $all: ["red", "blank"] } } )
 
 $all 이라는 연산자를 사용하면 red blank
 blank red인것 그리고 그외에 red blank plain 인 것을 다 찾는다.
 
 순서 상관 없이 red나 blank를 가지고만 있으면 값들을 추출한다. red가 ㄷ

db.inventory.find( { dim_cm: { $gt: 25 } } )
dim_cm은 25이상인 것을 찾아라는 의미 이다.


배열안에서 큰값을 가지고 있는것





db.inventory.find( { dim_cm: { $elemMatch: { $gt: 22, $lt: 30 } } } 이 두사이의 값들이 들어있는 모든 것을 다 출력 

$eleMatch는  22보다 크고 30보다 작은 값이 하나라도 있으면,

각각의 값이랑 맞는것 출력



db.inventory.find( { "dim_cm.1": { $gt: 25 } } )
dim_cm의 첫번째를 꺼내 겠다.


db.inventory.find( { "tags": { $size: 3 } } 

tags의 크기가 3인것을 출력하겠다.



db.inventory.find( { "dim_cm.1": { $gt: 25 } } )

dim_cm.1은 "" 를 사용해서 안에 넣어줘야 한다.



db.inventory.find( { "tags": { $size: 3 } } )

이값은 tags안의 배열의 크기 사이즈 안의 요소의 개수가 3개인 것들을 출력한다.

$size : 2하면 ["red","blank"] 같은 것들 출력



db.inventory.find( { "dim_cm.0": { $eq: 14 } } )  0 은 필드 의 0번째 이다. 0번째의 원소가 14인 것을 꺼내겠다.
. 은 값에 해당하는 객체에 접근 할 때

필드에 . 을 사용할 때는 인용 부호 "" '' 를 사용해서 묶어줘야하낟.




vlaue 값이 임베디드 객체인 경우



[ 임베디드 객체에 대한 쿼리 ]

db.inventory1.insertMany( [
 { item: "journal", qty: 25, size: { h: 14, w: 21,  임베디드 객체 형식으로 size 필드의 값을 구성하고 있다.
 uom: "cm" }, status: "A" },
 { item: "notebook", qty: 50, size: { h: 8.5, w: 11, 
 uom: "in" }, status: "A" },
 { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
 { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
 { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" }
]);

json 안에 또 json 형식이 들어오는 것을 임베디드 방식이라고 한다.

db.inventory1.find()



db.inventory1.find( { size: { h: 14, w: 21, uom: "cm" } } , {_id : false})

id를 제외한 나머지는 다 출력

id 를 true로 하면 나머지는 안나오고 id 만 나온다.





db.inventory1.find( { "size.uom": "in" }, {_id : false} )
만약 size에서 uom이 in이 것을 찾아라 할 때 사용

size.h : 14 하면 h가 14인 것을 찾겠다.



db.inventory1.find( { "size.h": { $lt: 15 } }, {_id : false} )
size.h:$lt: 15 하면 size.h가 15보다 작은 것을 찾겠다.

size.h가 h가 15보다 작은 것을 찾겠다.

db.inventory1.find( { "size.h": { $lt: 15 }, "size.uom": "in", status: "D" }, {_id : false} 
size.h가 15보다 작고 uom이 D인것을 찾겠다.

만약 uom 밑에(valud) 도 객체가 있으면 . 으로 계속 연결해 가면 된다.




[ 임베디드 객체를 원소로 갖는 배열 대한 쿼리 ]

db.inventory2.insertMany( [
 { item: "journal", instock: [ { warehouse: "A", qty: 5 }, { warehouse: "C", qty: 15 } ] },
 { item: "notebook", instock: [ { warehouse: "C", qty: 5 } ] },
 { item: "paper", instock: [ { warehouse: "A", qty: 60 }, { warehouse: "B", qty: 15 } ] },
 ###{ item: "planner", instock: [ { warehouse: "A", qty: 40 }, { warehouse: "B", qty: 5 } ] },  나는 이걸 입력안했음
 { item: "postcard", instock: [ { warehouse: "B", qty: 15 }, { warehouse: "C", qty: 35 } ] }
 
 원소들이 객체인 배열을 객체 배열이라고 한다.
 
 


db.inventory2.find( { 'instock.0.qty': { $lte: 20 } } )

instock이라는 배열에 할당된 배열에 0번째에 qty가 30보다 작거나 같으면



db.inventory2.find( { "instock": { warehouse: "A", qty: 5 } } ) -> instcok에서 warehouse가 "A"이고 qty가 5인 것을 출력한다.
결과 : { item: "journal", instock: [ { warehouse: "A", qty: 5 }, { warehouse: "C", qty: 15 } ] },


db.inventory2.find( { "instock": { qty: 5, warehouse: "A" } } ) - > instock에서 qty가 5 이고 warehouse가 "A"인것이 나온다.
결과 아무것도 출력되지 않는다. 이유는 QTY와 WAREHOUSE의 순서가 다르기 때문에

db.inventory2.find( { 'instock.qty': { $lte: 20 } } )
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d5f"), "item" : "journal", "instock" : [ { "warehouse" : "A", "qty" : 5 }, { "warehouse" : "C", "qty" : 15 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d60"), "item" : "notebook", "instock" : [ { "warehouse" : "C", "qty" : 5 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d61"), "item" : "paper", "instock" : [ { "warehouse" : "A", "qty" : 60 }, { "warehouse" : "B", "qty" : 15 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d62"), "item" : "postcard", "instock" : [ { "warehouse" : "B", "qty" : 15 }, { "warehouse" : "C", "qty" : 35 } ] }


instock.qty에서 lte가 20보다 작은 것을 가지고 있는 instock의 모든 qty가 다 출력 된다. instock 배열에 qty를 가지고 있는 객체는데 20보다 작은게 하나라도 있으면 그 배열 다 출력

db.inventory2.find( { 'instock.0.qty': { $lte: 20 } } )
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d5f"), "item" : "journal", "instock" : [ { "warehouse" : "A", "qty" : 5 }, { "warehouse" : "C", "qty" : 15 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d60"), "item" : "notebook", "instock" : [ { "warehouse" : "C", "qty" : 5 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d62"), "item" : "postcard", "instock" : [ { "warehouse" : "B", "qty" : 15 }, { "warehouse" : "C", "qty" : 35 } ] }

여기서는 instock.0.qty이므로 instco의 배열에서 0번째 객체에서 qty가 20보다 작은 것 들만 출력하므로 위의 instco.qty보다 하나 작게 출력 된다.

 db.inventory2.find( { "instock": { $elemMatch: { qty: 5, warehouse: "A" } } } )
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d5f"), "item" : "journal", "instock" : [ { "warehouse" : "A", "qty" : 5 }, { "warehouse" : "C", "qty" : 15 } ] }

여기서는 instock의 warehouse에서 "A"인것과 qty가 5인 것을 가지고 있으면 출력된다.




> db.inventory2.find( { "instock": { $elemMatch: { qty: { $gt: 10, $lte: 20 } } } } )
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d5f"), "item" : "journal", "instock" : [ { "warehouse" : "A", "qty" : 5 }, { "warehouse" : "C", "qty" : 15 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d61"), "item" : "paper", "instock" : [ { "warehouse" : "A", "qty" : 60 }, { "warehouse" : "B", "qty" : 15 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d62"), "item" : "postcard", "instock" : [ { "warehouse" : "B", "qty" : 15 }, { "warehouse" : "C", "qty" : 35 } ] }


여기서는 intock에서 qty가 10보다 크고 20보다 작은것들을 출력이므로 
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d60"), "item" : "notebook", "instock" : [ { "warehouse" : "C", "qty" : 5 } ] }
이거는 출력이 되지 않는다.





 db.inventory2.find( { "instock.qty": { $gt: 10, $lte: 20 } } )
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d5f"), "item" : "journal", "instock" : [ { "warehouse" : "A", "qty" : 5 }, { "warehouse" : "C", "qty" : 15 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d61"), "item" : "paper", "instock" : [ { "warehouse" : "A", "qty" : 60 }, { "warehouse" : "B", "qty" : 15 } ] }
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d62"), "item" : "postcard", "instock" : [ { "warehouse" : "B", "qty" : 15 }, { "warehouse" : "C", "qty" : 35 } ] }




db.inventory2.find( { "instock.qty": 5, "instock.warehouse": "A" } )

> db.inventory2.find( { "instock.qty": 5, "instock.warehouse": "A" } )
{ "_id" : ObjectId("61c3d60fadcdb7fab1f53d5f"), "item" : "journal", "instock" : [ { "warehouse" : "A", "qty" : 5 }, { "warehouse" : "C", "qty" : 15 } ] }



객체 단위로 체크해서 만족하는게 있으면 그 행을 꺼낸다.

db.inventory2.find("instock":{$elemMatch:{qty:{$gt:10,$


이거를 만ㄷ족하는 애가 하나라도 있나 qty가 만족하는게 하나라도 있으면 
gt 에 만족하는애가 있으면, 

lte20을 만족하는 애가 있으며

각각의 조건을 만족하는게 잇으면 꺼낸다.





/////////////////////////////////////////
23페이지



몽고디비에서 저장단위 도큠ㄴ트


값이 객체인 경우 임베딩 객체라고 한다.






[ 반환(return) 값 : Cursor 객체 ]
query에 해당하는 Document들을 선택하여 cursor를 반환한다. cursor 는 query 요청의 결과값을 가르키는 pointer 이다. 
Cursor 객체를 통해서 보이는 데이터의 수를 제한할 수 있고, 데이터를 sort 할 수도 있다. 생성된 Cursor 객체의 내용은 한 번만
읽을 수 있으며 10분동안 사용하지 않으면 만료된다.



find한 결과를 변수에 담는다.


자바스크립트는 자바와 다르게

자바는 타입을 설정하지만(그래서 타입의 값만 저장 할 수 있다)  변수가 받게될 값을 고정 시킴으로서 얻을수 있는 장점도 있고 단ㄷ점도 잇다.


자바스크립트는 타입의 값
고정하는것도 아니고 고정 안하는것도 아니다 어떤값을 사용할거라는 값만 저장한다.

이때 사용하는 예약어가 var가 있다.

rat이나 con어쩌고 가 있다.

var를 안붙이면 변수명을 mycursor라고 하는 이유는

jdbc의 result도 커서 객체이다.

jdbc의 result 셋의 장점은 포워드 방향으로 한번만 읽을 수 있다.

cursor 객체의 공통된 내요은 한번만 읽을 수 있으며 

10분동안 사용ㅈ만료된다.


\



도큐먼트를 변수에 담는 이유는 

하나하나 한 도큐먼트씩 꺼내기 위해서이다.

hasNext()와

next() 메소드를 사용하여 하나 하나 꺼내온다.

resultSet은 다음해으로 next가 찾는동안  넘어갔다 안ㄴ넘어갔다 알수 있다.??????????


다음 도큐먼트로 넘어가는 기능만 한다.

hasNext가 참인동안 하나하나 꺼내와라

자바는 어떤 객체를 출력하시오라고 하면 자동으로 toString이 출력된다.
이것도 마찬가지로 toString으로 출력되어서 object bson이라고 나온다.






printjson(doc)

json 형식으로 doc 먼트를 내용을 json형식으로 내보내 준다.




   ///////////////////////////////////////////
   
   24페이지
   
   db.book.find().skip(2).limit(2)
   
   skip을 2단계 건너뛰고 limit(2) 두개 표시
   
   
   
   
   tojson은 json형식으로 나타낸다
   json 형식과 같은 의미
   
   변환해서 출력까지 하려먼 printjson이 간단하고  도큐먼트를 json으로 만들어서 출력
    
   tojosn 은 변환까지만
   
   for each 사용하면 반복문 따로 사요ㅇ안해도 된다.
   
   함수 이름을 argument로 주면  cursor 객체는 추출된 객채 만큼의 도큐먼트 객체가 있는데
   아규먼트로 된 도큐먼트 객체들을 그대로 화면에 내보낸다. 
   
   myCursor.forEach(print) 프린트 사용
   
   json으로 바꾸지 않고 object bson형식이 나온다.
   
   도큐먼트를 가지고 printjson으로 출력해달라고 호출하는 것이다.
   
   데이터의 집합을 다루는 객체는 foreach를 다루는 것이 많다.
   
   
   
   
   /////////////////////////////////////////
   
   25 페이지
   
   커서는 대괄호1 숫자 인덱스를 사용할 수 있는것은 배열이다.
   
   커서 객체는 유사 배열이다.
   
   while 문을 가지고 hasNext next로 읽어와도 되고
   
   foreach로 해도 되고 
   
   indexing 방식으로 하나하나 꺼내올 수 있다.
   
   mycursor에 의해 꺼내와지는 도큐먼트
   
   
   주어진 find moethod에 의해서 ㅊ출된 도큐먼트가
   
   대괄호 했을 때 undefined ??    
   
   find 메소드에 의해서 
   
   foreach 메소드
   
   원소에 해당되는 단어를 하나하나 꺼내는 방법
   
   toarray 사용하면 어레이로 변화을 시켜준다.
   
   
   
 var myArray = myCursor.toArray()로 변환하고 나면 
   
   myCursor에는 ㅁ아무 값도 없다
   
   myArray에 들어가 잇다.
   
   추출된 
   
   각가의 도큐먼트에 대하여 어떤 작을 하느냐는 프로그램마다 다른데
   
   도큐먼트를 꺼내서 처리하는 방법은 다양하다.
   
   
   
   
   find(jumsu : {$eq:null}}} 점수 필드가 안기자고 있으면 한개 출력
   
   이름 필드가 null인것은 없다.
   
   객체는 잇는데 값이 "" 인것은  널문자열이라고 한다. 필드는 있지만 값이 없는 것을 의미
   
   네임이 null이 아닌 것은 이름 필드가 없는 것을 말함
   
   
   
   [ Query 연산자 ]
프로그래밍 언어에서 >, <, <=, ==, != 등 연산자가 있는 것 처럼, MongoDB 에서도 원하는 데이터를 찾기 위해 연산자를 사용한다. 
연산자의 종류는 비교(Comparison), 논리(Logical), 요소(Element), 배열(Array) 등 여러 종류가 있다.
[ 비교(Comparison) 연산자 ]
$eq (equals) 주어진 값과 일치하는 값
$gt (greater than) 주어진 값보다 큰 값
$gte (greather than or equals) 주어진 값보다 크거나 같은 값
$lt (less than) 주어진 값보다 작은 값
$lte (less than or equals) 주어진 값보다 작거나 같은 값
$ne (not equal) 주어진 값과 일치하지 않는 값
$in 주어진 배열 안에 속하는 값
$nin 주어빈 배열 안에 속하지 않는 값  not in




///////////////////////////

26페이지

[ 논리 연산자 ]
$or 주어진 조건중 하나라도 true 일 때 true
$and 주어진 모든 조건이 true 일 때 true
$not 주어진 조건이 false 일 때 true
$nor 주어진 모든 조건이 false 일때 true




$regex 정규표현식에 매칭되는 값, 자바스크립트의 정규표현식 객체 = /XXXX/ . 앞뒤에 / 슬래시를 붙이면 정규표현식이 된다.
$regex 정규표현식에


{필드명 :{$eq:'abc'}}  주어진 필드명이 주어진 abc와 비교한다.
 필드명 :'abc'  필드에 주어진 값이 abc인 애를 찾아라
와

{필드명 :{$eq: /abc/}} 는 다르다
필드명:/abc/  이건 식이다.  식으로서 인용부호 붙이지 않는다.
예를 들어 '10+20' 


필드명에 포함된 abc를 찾아라  필드명에 like 연산자 써서 

필드명 like '%abc%' 와 같은 의미다.

비교값에 정규 표현식을 주면 자동으로 패턴 비교가 된다.

위에껀 abc를 찾아라
밑에껀 abc가 들어간 것을 찾아라

^abc = 'abc%' 와 같은 의미이다.

abc$ 이러고 끝나는




.x는 앞에 어떤 문자가 됐든 임의의 문자 하나가 오는걸 찾는다.


x+ 는 + 앞에 나온 문자가 한개 이상을 출력 한다.

/java+/ 는 java도 찾고  javaa도 찾고 

javaaaaaa도 찾는다 
a+는 바로 앞에 나온 문자를 한번이상 반복을 뜻한다.

/java+/  --> java, javaaa, javaaaaa, javaaaaaaaaaaaaa

/java?/ 는 ? 물음표는 바로앞의 문자가 0번 또는 한번을 뜻한다.

/java?/ 는 jav, java와 같은 것이다. 

/java*/ 는 0개 이상을 뜻한다.   
/ja(va)*/이렇게 하면 va에 대해서 0번이상 출력

        jav, java, javaa, javaaaaaa에 다 매칭 된다.
        
        
+ 기호는 바로 앞의 문자가 1번 이상 반복되는 것을 뜻함

? : 0번 또는 1번을 뜻한다.

* : 은  0번 이상을 뜻한다.

x|y는 or를 뜻한다.



        /java(3)/ 을 하면  ------> javaaa  는 ()괄호의 바로 앞의 문자의 반복 횟수를 의미
        /java(3,5) 를 하면 3번 부터 5번을 뜻한다.    --------. javaaa,javaaaa, javaaaaa 를 의미
        /java(3,)는 3번이상 몇번이 나오든 3번 이상을 뜻한다.
        
        
        
        
        /a|b|c|d|e/ ---> /[abcde]/  두개 같은 의미인데 a 또는 b 또는 c 또는 d 또는 e또는 이라는 의미이다.
        -------->>> [a-e] 알파벳 문자 a 에서 e 까지이다.
        
        
        
        /[A-Za-z]/ 영문 대소문자를 의미한다.
        일반적으ㅗㄹ
        /[A-z]/ 는 틀린것이다. 그 이유는 A에서 z사이의 값의 범위는 중간에 값이 없다.
        
        
        한글은 
        /[가-힣]/을 의미 한다.
        
        대과호 안에는 코드값이 큰애 
        
        
        
        
        
        /[0123456789]/ 숫자를 나타내는 정규 표현식
        
        /[0-9]/ 숫자를 의미 한다.
       
        ---> \d 하면 같은 의미이다.ㄷ 밸슬래시   0에서 9까지의 숫자를 나타낸다.
        
        \d{4}\ - \d{4} - \d{4} 는 핸드폰을 의미 한다.















/////////////////////////////////////////////





{ name: { $in: [ /^acme/i, /^ack/ ] } }  name 이 acme으로 시작하는 것을 찾는다.

 ㅜ믇d이 acme로 시작하거나 ack로 시작하는것 acme는 대소문자 구분하지 않고라는 옵션이 들어갔다.  i를 안주면 대소문자 들어간다.

db.inventory.find( { item: { $not: /^p.*/ } } )   -> 정규표현식 객체  만약 정규표현식을 사용해라면 이것이다.




db.inventory.find( { item: { $not: { $regex: "^p.*" } } } )  p로 시작하고 p뒤에 임의의 문자가 0개 이상 올 수 있다.    .은 문자하나를 뜻하고 * 은 여러번 반복할 수 잇다.
그런데 not 연산자를 사용했기 대문에 이게 아닌 것을 찾아라느 의미  


db.inventory.find( { item: { $not: { $regex: /^p.*/ } } }  ->  /^p.*/  정규표현식 객체이다.   { "_id" : 100, "sku" : "abc123", "description" : "Single line description." }
{ "_id" : 101, "sku" : "abc789", "description" : "First line\nSecond line" }
{ "_id" : 102, "sku" : "xyz456", "description" : "Many spaces before line" }
{ "_id" : 103, "sku" : "xyz789", "description" : "Multiple\nline description" }





{ "_id" : 100, "sku" : "abc123", "description" : "Single line description." } -> sku가 abc로 시작하는



{ "_id" : 101, "sku" : "abc789", "description" : "First line\nSecond line" }   \n 행바꿈 문자
{ "_id" : 102, "sku" : "xyz456", "description" : "Many spaces before line" }
{ "_id" : 103, "sku" : "xyz789", "description" : "Multiple\nline description" }


db.products.find( { sku: { $regex: /789$/ } } )
db.products.find( { sku: { $regex: /^ABC/i } } )   ABC로시작하는 i는 대소문자 구별한다.

db.products.find( { description: { $regex: /^S/, $options: 'm' } } )    -> 이러한 정규표현식에 만족하는 것을 찾겠다.
regex라는 연산자를 썼다.  대문자 S로 시작하는 options에 해당하는 값은 /

/^S/m을 붙이면 뒤에 options를 생략해도 된다.   m은 멀티플이라는 읜미 앞에 s라는 것을 찾아달라는 의미  m은 다중행의 의미  대문자 S로 시작하는 것을 찾는데  m을 주면 
{ "_id" : 100, "sku" : "abc123", "description" : "Single line description." } -> sku가 abc로 시작하는
{ "_id" : 101, "sku" : "abc789", "description" : "First line\nSecond line" }   \n 행바꿈 문자     
m은 위의 descrption에서 S를 찾게 해준다. 옵션으로 m을 안주면 첫번째에 들어가 있는 Single line description.  S만 찾는다.
그리고 m을 주면 행이 구분되는 곳에서도 S를 찾는다.






db.products.find( { description: { $regex: /^S/, $options: 'm' } } )
-> S는 




db.products.find( { description: { $regex: /m.*line/, $options: 'si' } } )  si는 공백 문자 (스페이스 문자도) 스페이스 문자도 일반문자로 적용해라
이문장을 실행시키면 밑의 문장이 찾아진다.
{ "_id" : 103, "sku" : "xyz789", "description" : "Multiple\nline description"  


"Multiple\nline   이문장이

/m.*line/ 이문자에 의해 찾아내 진다.



 "Single line description." 이문장에서는 line이 있지만 
 앞에 s이므로 찾아지지 않는다.



[ Database 제거 : db.dropDatabase() ]
이 명령어를 사용하기 전, use DATABASE_NAME 으로 삭제하고자 하는 데이터베이스를 선택한다.
> use 데이터베이스명
> db.dropDatabase();
> show dbs



[ Collection 생성 : db.createCollection() ]
Collection을 생성할 때는 db.createCollection(name, [options]) 명령어를 사용한다. 또한 콜렉션은 도큐먼트를 최초로 저장할 때
자동으로 생성되므로 직접 생성하지 않아도 된다.

> use test
switched to db test
> db.createCollection("game")
> show collections




[ Collection 제거 : db.COLLECTION_NAME.drop() ]
> use test
switched to db test
> show collections
> db.컬렉션이름.drop()
> show collections


///////////////////////////////////

28

[ Document 추가 : db.COLLECTION_NAME.insert(document) ]
> db.book.insertMany({"name": "CSS3", "price": 17000})
> db.book.insert([
{"name": "pandas", "price": 21000},
{"name": "R", "price": 23000}

도큐먼트는 반듯이 json 객체 형식으로 만들어져 있어야 한다.

insertMany는 다중 도큐먼트를 집어넣는 것이다.



remove는 삭제하는 것이다.



> db.book.find()
[ Document 제거: db.COLLECTION_NAME.remove(criteria, justOne) ]    criteria 객체
parameter type 설명
criteria document 삭제할 데이터의 기준 값(criteria)이다. 
이 값이 { } 이면 컬렉션의 모든 데이터를 제거한다.
justOne boolean 선택적(Optional) 매개변수이며 이 값이 true 면 1개 의 다큐먼트만 제
거한다. 이 매개변수가 생략되면 기본값은 false 로서, criteria에 해당되
는 모든 다큐먼트를 제거한다.
> db.book.find({"name": "R"})   이름이 R인 책이름을 찾는다.
> db.book.remove({"name": "R"})   이름이 R인 책을 삭제 한다.

> db.book.find()




update
[ Document 수정: db.COLLECTION_NAME.update({ matchQuery }, { updateQuery }, { optionQuery }) ]
matchQuery - 원하는 값을 찾을 검색 쿼리
updateQuery - 일치하는 document(row)를 찾은 후 변경할 쿼리 입력
optionQuery - 동작 방식에 대한 옵션
 - upsert: <Boolean>
update와 insert를 합성한 단어로 만약 matchQuery에서 일치하는 결과가 없는 경우 새로운 값을 추
가(insert)할 것인지의 여부를 선택할 수 있습니다. 값은 true/false로 설정하며 기본값은 false임
- multi: <Boolean>
multi:true를 설정하면 여러 개의 일치하는 document(row)가 존재할 경우 모두 변경. 기본값은 false
이며 하나의 document만 변경
> db.book.update({"name": "python"},{ "name" : "python", "price":10000 })
> db.book.update({"name": "pandas"},{ "name" : "pandas", "price":20000 }, {upsert : true} )
> db.book.update({"name": "python"},{$set:{"price":10000}})




{ matchQuery }, { updateQuery }, { optionQuery }


{ optionQuery }  update와 insert의 합성어이다.

멀티가 true면 조건에 맞는 애들을 수정한다.

multi가 false면 하나만 수정 한다.




upsert는 조건에 알맞은 도큐먼트를 보니까 주어진 필드명에 해당되는 내용이 이미 있으면 value만 바꾼다.

새로운 값을 추가 한다.

업데이트 하고자 하는 필드명이 존재하면 값만 바꾸고 아니면 새로이 추가 한다.

업데이트와 insert를 합성한 단어다.  upsert라는 의미

- upsert: <Boolean>
update와 insert를 합성한 단어로 만약 matchQuery에서 일치하는 결과가 없는 경우 새로운 값을 추
가(insert)할 것인지의 여부를 선택할 수 있습니다. 값은 true/false로 설정하며 기본값은 false임


> db.book.update({"name": "python"},{ "name" : "python", "price":10000 })   네입이 파ㅏ이썬인 도큠ㄴ트를 찾는다 파이썬인 네임을 
한꺼번에 지정  이름이 파이썬인 도큐먼트가 있는데 파이썬은 그대로 하고 싶고 가격만 바꾸고 시다면 두번째 아규먼트가 바꾹싶은 내용인데

이때 파이썬이라는 내용을 찾아서 새 도큐 먼트를 추가해
찾고자 하는 책의 내용도 파이썬 이고 
{ "name" : "python", "price":10000 }) 새롭게 추가할 내용도 파이썬이다.

가격만 바꾸고 싶다면 update라는 메소드를 사용하면서 네임을 빼고 price만 주면

파이썬이라는 값을 가지는 파이선은 사라지고 price만 남게 된다.

어떤한 필드 값을 갖는 필드값을 바꾸고 싶다면 특정 필드만 바꾸고자 한다면 

> db.book.update({"name": "python"},{$set:{"price":10000}}
set 연산자를 사용해서 바꿔야 한다.



> db.book.update({"name": "pandas"},{ "name" : "pandas", "price":20000 }, {upsert : true} )
이름이 판다스 인 것을 찾아라 판다스라는 이름을 갖는 도큐먼트가 존재하지 않으면 새로이 추가되고 존재하면  { "name" : "pandas", "price":20000 }, {upsert : true}
이걸로 바뀌고 이렇게 바뀌는 조건은 upsert를 true로 줬기 때문이다.

> db.book.update({"name": "python"},{$set:{"price":10000}}


컬렉션 복사 : db.컬렉션 이름.copyToAll(새로운 컬렉션 이름)

